<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第八周复杂数据类型的机器级表示 - 计算机系统基础</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="弁言.html"><strong aria-hidden="true">1.</strong> 弁言</a></li><li class="chapter-item expanded "><a href="第一周计算机系统概述.html"><strong aria-hidden="true">2.</strong> 第一周计算机系统概述</a></li><li class="chapter-item expanded "><a href="第二周数据的表示和存储.html"><strong aria-hidden="true">3.</strong> 第二周数据的表示和存储</a></li><li class="chapter-item expanded "><a href="第三周运算电路基础.html"><strong aria-hidden="true">4.</strong> 第三周运算电路基础</a></li><li class="chapter-item expanded "><a href="第四周乘除运算及浮点数运算.html"><strong aria-hidden="true">5.</strong> 第四周乘除运算及浮点数运算</a></li><li class="chapter-item expanded "><a href="第五周IA-32指令系统概述.html"><strong aria-hidden="true">6.</strong> 第五周IA-32指令系统概述</a></li><li class="chapter-item expanded "><a href="第六周IA-32指令类型.html"><strong aria-hidden="true">7.</strong> 第六周IA-32指令类型</a></li><li class="chapter-item expanded "><a href="第七周C语言语句的机器级表示.html"><strong aria-hidden="true">8.</strong> 第七周C语言语句的机器级表示</a></li><li class="chapter-item expanded "><a href="第八周复杂数据类型的机器级表示.html" class="active"><strong aria-hidden="true">9.</strong> 第八周复杂数据类型的机器级表示</a></li><li class="chapter-item expanded "><a href="第九周x86-64指令系统.html"><strong aria-hidden="true">10.</strong> 第九周x86-64指令系统</a></li><li class="chapter-item expanded "><a href="第十周链接概述和目标文件格式.html"><strong aria-hidden="true">11.</strong> 第十周链接概述和目标文件格式</a></li><li class="chapter-item expanded "><a href="第十一周符号及符号解析.html"><strong aria-hidden="true">12.</strong> 第十一周符号及符号解析</a></li><li class="chapter-item expanded "><a href="第十二周重定位及动态链接.html"><strong aria-hidden="true">13.</strong> 第十二周重定位及动态链接</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">计算机系统基础</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第八周复杂数据类型的机器级表示"><a class="header" href="#第八周复杂数据类型的机器级表示">第八周复杂数据类型的机器级表示</a></h1>
<p><a href="https://rosefinch-midsummer.github.io/book/file/cs/course1-week8.pdf" target="_blank">在线阅读PDF文档</a></p>
<ul>
<li><a href="#%E7%AC%AC1%E8%AE%B2-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE">第1讲 数组和指针类型的分配和访问</a>
<ul>
<li><a href="#1%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E8%AE%BF%E9%97%AE19%E5%88%86%E9%92%9F">1.数组的分配与访问（19分钟）</a></li>
<li><a href="#2%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB9%E5%88%86%E9%92%9F">2.数组与指针的关系（9分钟）</a></li>
<li><a href="#3%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%8419%E5%88%86%E9%92%9F">3.指针数组和多维数组（19分钟）</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC2%E8%AE%B2-%E7%BB%93%E6%9E%84%E5%92%8C%E8%81%94%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE">第2讲 结构和联合数据类型的分配和访问</a>
<ul>
<li><a href="#1%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE20%E5%88%86%E9%92%9F">1.结构类型的分配和访问（20分钟）</a></li>
<li><a href="#2%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE18%E5%88%86%E9%92%9F">2.联合类型的分配和访问（18分钟）</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC3%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E9%BD%90%E5%AD%98%E6%94%BE">第3讲 数据的对齐存放</a>
<ul>
<li><a href="#1%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F14%E5%88%86%E9%92%9F">1.数据的对齐方式（14分钟）</a></li>
<li><a href="#2%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F%E4%B8%BE%E4%BE%8B14%E5%88%86%E9%92%9F">2.数据对齐方式举例（14分钟）</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC4%E8%AE%B2-%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB">第4讲 越界访问和缓冲区溢出攻击</a>
<ul>
<li><a href="#%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB27%E5%88%86%E9%92%9F">越界访问和缓冲区溢出攻击（27分钟）</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%85%AB%E5%91%A8%E5%B0%8F%E6%B5%8B%E9%AA%8C">第八周小测验</a>
<ul>
<li><a href="#1%E6%B1%82a2%E5%9C%B0%E5%9D%80">1求<code>a[2]</code>地址</a></li>
<li><a href="#2%E4%BC%A0%E5%80%BC%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">2传值汇编指令</a></li>
<li><a href="#3%E4%BC%A0%E5%80%BC%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">3传值汇编指令</a></li>
<li><a href="#4%E4%BC%A0%E9%80%81%E9%A6%96%E5%9C%B0%E5%9D%80%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">4传送首地址汇编指令</a></li>
<li><a href="#5%E8%AF%A6%E8%A7%A3ptri">5详解<code>ptr+i</code></a></li>
<li><a href="#6%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%9C%B0%E5%9D%80">6二维数组元素地址</a></li>
<li><a href="#7%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC">7指针数组元素的值</a></li>
<li><a href="#8%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%9C%B0%E5%9D%80">8指针数组元素的地址</a></li>
<li><a href="#9%E7%BB%93%E6%9E%84%E4%BD%93%E5%85%83%E7%B4%A0%E8%B5%8B%E5%80%BC%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4">9结构体元素赋值汇编指令</a></li>
<li><a href="#10%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F">10对齐方式</a></li>
</ul>
</li>
</ul>
<h2 id="第1讲-数组和指针类型的分配和访问"><a class="header" href="#第1讲-数组和指针类型的分配和访问">第1讲 数组和指针类型的分配和访问</a></h2>
<h3 id="1数组的分配与访问19分钟"><a class="header" href="#1数组的分配与访问19分钟">1.数组的分配与访问（19分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310201028371.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310201049571.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310201057231.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310201106764.png" alt="" /></p>
<p>注：这里如果使用mov指令，则会把ebx寄存器中内容10传送到edx寄存器。</p>
<h3 id="2数组与指针的关系9分钟"><a class="header" href="#2数组与指针的关系9分钟">2.数组与指针的关系（9分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310211017586.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310211046684.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310211046042.png" alt="" /></p>
<p><strong>movl 传送内容，leal 传送地址</strong></p>
<p>其中第5个不好理解，测试程序及结果如下：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    int A[10] = {1,2,3,4,5,6,7,8,9,10};
    printf(&quot;%d&quot;,&amp;A[7]-A);
    return 0;
}
</code></pre>
<pre><code>7
</code></pre>
<p>第5条也可以用leal指令实现。</p>
<h3 id="3指针数组和多维数组19分钟"><a class="header" href="#3指针数组和多维数组19分钟">3.指针数组和多维数组（19分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310211054180.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310211126339.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    static short num[][4] = {{2,9,-1,5},{3,8,2,-6}};
    static short *pn[2] = {num[0],num[1]};
    static short s[2] = {0,0};
    int i,j;
    for(i=0;i&lt;2;i++)
    {
        for(j=0;j&lt;4;j++)
            s[i] += *pn[i]++;
        printf(&quot;sum of line %d is %d\n&quot;,i,s[i]);
    }
    return 0;
}
</code></pre>
<pre><code>sum of line 0 is 15
sum of line 1 is 7
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main()
{
    static short num[][4] = {{2,9,-1,5},{3,8,2,-6}};
    static short *pn[2] = {num[0],num[1]};
    static short s[2] = {0,0};
    int i,j;
    for(i=0;i&lt;2;i++)
    {
        for(j=0;j&lt;4;j++)
        {
            s[i] += num[i][j];
            printf(&quot;0x%x\n&quot;,&amp;num[i][j]);
        }
        printf(&quot;sum of line %d is %d\n&quot;,i,s[i]);
    }
    return 0;
}
</code></pre>
<pre><code>0x403010
0x403012
0x403014
0x403016
sum of line 0 is 15
0x403018
0x40301a
0x40301c
0x40301e
sum of line 1 is 7
</code></pre>
<p><font color="yellow">静态区地址是按代码顺序从低地址向高地址增长的，这和栈区不同！！</font></p>
<p><font color="yellow">静态区地址是按代码顺序从低地址向高地址增长的，这和栈区不同！！</font></p>
<p><font color="yellow">静态区地址是按代码顺序从低地址向高地址增长的，这和栈区不同！！</font></p>
<h2 id="第2讲-结构和联合数据类型的分配和访问"><a class="header" href="#第2讲-结构和联合数据类型的分配和访问">第2讲 结构和联合数据类型的分配和访问</a></h2>
<h3 id="1结构类型的分配和访问20分钟"><a class="header" href="#1结构类型的分配和访问20分钟">1.结构类型的分配和访问（20分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310221053808.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;


int main()
{
    int m = 0;
    struct cont_info
    {
        char id[8];
        char name [12];
        unsigned post;
        char address[100];
        char phone[20];
    };
    struct cont_info x = {&quot;0000000&quot;,&quot;ZhangS&quot;,210022,&quot;273 long street,High Building#3015&quot;,&quot;12345678&quot;};
    int n = 1;
    printf(&quot;0x%x\n&quot;,&amp;m);
    printf(&quot;0x%x\n&quot;,&amp;(x.id));
    printf(&quot;0x%x\n&quot;,&amp;(x.name));
    printf(&quot;0x%x\n&quot;,&amp;(x.post));
    printf(&quot;0x%x\n&quot;,&amp;(x.address));
    printf(&quot;0x%x\n&quot;,&amp;(x.phone));
    printf(&quot;0x%x\n&quot;,&amp;n);

    printf(&quot;%d\n&quot;,&amp;m);
    printf(&quot;%d\n&quot;,&amp;(x.id));
    printf(&quot;%d\n&quot;,&amp;(x.name));
    printf(&quot;%d\n&quot;,&amp;(x.post));
    printf(&quot;%d\n&quot;,&amp;(x.address));
    printf(&quot;%d\n&quot;,&amp;(x.phone));
    printf(&quot;%d\n&quot;,&amp;n);

    return 0;
}
</code></pre>
<pre><code>0x62fe0c
0x62fd70
0x62fd78
0x62fd84
0x62fd88
0x62fdec
0x62fd6c
6487564
6487408
6487416
6487428
6487432
6487532
6487404
</code></pre>
<p><strong>这个程序中结构体变量和m、n存储位置相同，都在栈区。</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct cont_info
{
    char id[8];
    char name [12];
    unsigned post;
    char address[100];
    char phone[20];
};

struct cont_info x = {&quot;0000000&quot;,&quot;ZhangS&quot;,210022,&quot;273 long street,High Building#3015&quot;,&quot;12345678&quot;};

int main()
{
    printf(&quot;0x%x\n&quot;,&amp;(x.id));
    printf(&quot;0x%x\n&quot;,&amp;(x.name));
    printf(&quot;0x%x\n&quot;,&amp;(x.post));
    printf(&quot;0x%x\n&quot;,&amp;(x.address));
    printf(&quot;0x%x\n&quot;,&amp;(x.phone));
    printf(&quot;%d\n&quot;,&amp;(x.id));
    printf(&quot;%d\n&quot;,&amp;(x.name));
    printf(&quot;%d\n&quot;,&amp;(x.post));
    printf(&quot;%d\n&quot;,&amp;(x.address));
    printf(&quot;%d\n&quot;,&amp;(x.phone));
    return 0;
}
</code></pre>
<pre><code>0x62fe1c
0x403020
0x403028
0x403034
0x403038
0x40309c
0x62fe18
6487580
4206624
4206632
4206644
4206648
4206748
6487576
</code></pre>
<p><strong>这个程序中结构体变量和m、n存储位置不同，前者在静态区，后者在栈区。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310221206690.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310221206397.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310221208232.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202310221216035.png" alt="" /></p>
<h3 id="2联合类型的分配和访问18分钟"><a class="header" href="#2联合类型的分配和访问18分钟">2.联合类型的分配和访问（18分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310230818924.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    union uarea
    {
        char c_data;
        short s_data;
        int i_data;
        long l_data;
    }u;
    printf(&quot;The size of uarea is %d\n&quot;,sizeof(u));
    return 0;
}
</code></pre>
<pre><code>The size of uarea is 4
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310230830279.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
unsigned float2unsign(float f)
{
    union
    {
        float f;
        unsigned u;
    }tmp_union;
    tmp_union.f = f;
    return tmp_union.u;
}
int main()
{
    printf(&quot;%d&quot;,float2unsign(10.0));
    return 0;
}
</code></pre>
<pre><code>1092616192
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310230834660.png" alt="" /></p>
<h2 id="第3讲-数据的对齐存放"><a class="header" href="#第3讲-数据的对齐存放">第3讲 数据的对齐存放</a></h2>
<h3 id="1数据的对齐方式14分钟"><a class="header" href="#1数据的对齐方式14分钟">1.数据的对齐方式（14分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310230841317.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310230847700.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310230856187.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    struct cont_info
    {
        short si;
        int i;
        char c;
        double f;
    };
    struct cont_info x = {100,9,'A',10.0};

    printf(&quot;0x%x\n&quot;,&amp;(x.si));
    printf(&quot;0x%x\n&quot;,&amp;(x.i));
    printf(&quot;0x%x\n&quot;,&amp;(x.c));
    printf(&quot;0x%x\n&quot;,&amp;(x.f));

    printf(&quot;%d\n&quot;,&amp;(x.si));
    printf(&quot;%d\n&quot;,&amp;(x.i));
    printf(&quot;%d\n&quot;,&amp;(x.c));
    printf(&quot;%d\n&quot;,&amp;(x.f));

    return 0;
}
</code></pre>
<pre><code>0x62fe00
0x62fe04
0x62fe08
0x62fe10
6487552
6487556
6487560
6487568
</code></pre>
<p>6487569/8=810946</p>
<p>Windows系统中double类型确实是按8个字节对齐的即地址是8的倍数！</p>
<p>这种写法太浪费空间了！！</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    struct cont_info
    {
        int i;
        short si;
        double f;
        char c;
    }sa[10];
    struct cont_info x = {100,9,10.0,'A'};
    printf(&quot;The size of x is %d\n&quot;,sizeof(x));
    printf(&quot;The size of sa is %d\n&quot;,sizeof(sa));

    printf(&quot;0x%x\n&quot;,&amp;(x.i));
    printf(&quot;0x%x\n&quot;,&amp;(x.si));
    printf(&quot;0x%x\n&quot;,&amp;(x.f));
    printf(&quot;0x%x\n&quot;,&amp;(x.c));

    printf(&quot;%d\n&quot;,&amp;(x.i));
    printf(&quot;%d\n&quot;,&amp;(x.si));
    printf(&quot;%d\n&quot;,&amp;(x.f));
    printf(&quot;%d\n&quot;,&amp;(x.c));

    return 0;
}
</code></pre>
<pre><code>The size of x is 24
The size of sa is 240
0x62fd10
0x62fd14
0x62fd18
0x62fd20
6487312
6487316
6487320
6487328
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310230857418.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    struct cont_info
    {
        int i;
        char c;
        short si;
        double f;
    };
    struct cont_info x = {100,'A',9,10.0};
    printf(&quot;0x%x\n&quot;,&amp;(x.i));
    printf(&quot;0x%x\n&quot;,&amp;(x.c));
    printf(&quot;0x%x\n&quot;,&amp;(x.si));
    printf(&quot;0x%x\n&quot;,&amp;(x.f));

    printf(&quot;%d\n&quot;,&amp;(x.i));
    printf(&quot;%d\n&quot;,&amp;(x.c));
    printf(&quot;%d\n&quot;,&amp;(x.si));
    printf(&quot;%d\n&quot;,&amp;(x.f));

    return 0;
}
</code></pre>
<pre><code>0x62fe10
0x62fe14
0x62fe16
0x62fe18
6487568
6487572
6487574
6487576
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
    struct cont_info
    {
        int i;
        short si;
        char c;
        double f;
    };
    struct cont_info x = {100,9,'A',10.0};
    printf(&quot;0x%x\n&quot;,&amp;(x.i));
    printf(&quot;0x%x\n&quot;,&amp;(x.si));
    printf(&quot;0x%x\n&quot;,&amp;(x.c));
    printf(&quot;0x%x\n&quot;,&amp;(x.f));

    printf(&quot;%d\n&quot;,&amp;(x.i));
    printf(&quot;%d\n&quot;,&amp;(x.si));
    printf(&quot;%d\n&quot;,&amp;(x.c));
    printf(&quot;%d\n&quot;,&amp;(x.f));

    return 0;
}
</code></pre>
<pre><code>0x62fe10
0x62fe14
0x62fe16
0x62fe18
6487568
6487572
6487574
6487576
</code></pre>
<h3 id="2数据对齐方式举例14分钟"><a class="header" href="#2数据对齐方式举例14分钟">2.数据对齐方式举例（14分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310231003290.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310231032915.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdint-gcc.h&gt;
#include &lt;stdio.h&gt;
#pragma pack(4)
typedef struct
{
    uint32_t f1;
    uint8_t f2;
    uint8_t f3;
    uint32_t f4;
    uint64_t f5;
}__attribute__((aligned(1024))) ts;

int main()
{
    printf(&quot;Struct size is: %d, aligned on 1024\n&quot;,sizeof(ts));
    printf(&quot;Allocate f1 on address:0x%x\n&quot;,&amp;(((ts*)0)-&gt;f1));
    printf(&quot;Allocate f2 on address:0x%x\n&quot;,&amp;(((ts*)0)-&gt;f2));
    printf(&quot;Allocate f3 on address:0x%x\n&quot;,&amp;(((ts*)0)-&gt;f3));
    printf(&quot;Allocate f4 on address:0x%x\n&quot;,&amp;(((ts*)0)-&gt;f4));
    printf(&quot;Allocate f5 on address:0x%x\n&quot;,&amp;(((ts*)0)-&gt;f5));
    return 0;
}
</code></pre>
<pre><code>Struct size is: 1024, aligned on 1024
Allocate f1 on address:0x0
Allocate f2 on address:0x4
Allocate f3 on address:0x5
Allocate f4 on address:0x8
Allocate f5 on address:0xc
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310231047989.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
//#pragma pack(1)

struct test
{
    char x2;
    int x1;
    short x3;
    long long x4;
}__attribute__((packed));

struct test1
{
    char x2;
    int x1;
    short x3;
    long long x4;
};

struct test2
{
    char x2;
    int x1;
    short x3;
    long long x4;
}__attribute__((aligned(8)));

int main()
{
    printf(&quot;size=%d\n&quot;,sizeof(struct test));
    printf(&quot;size=%d\n&quot;,sizeof(struct test1));
    printf(&quot;size=%d\n&quot;,sizeof(struct test2));
    return 0;
}
</code></pre>
<p>在Windows10（按8字节对齐）下执行结果：</p>
<pre><code>size=24
size=24
size=24
</code></pre>
<p>紧凑方式没起作用。</p>
<p>在WSL2（Ubuntu22.04LTS）上执行结果如下：</p>
<pre><code>size=15
size=24
size=24
</code></pre>
<p>中间这个按自然边界对齐的方式所占用字节数和课程中讲到的不同。。</p>
<p>在Ubuntu系统上这个程序执行结果也是上面这样。。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310231049207.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#pragma pack(1)

struct test
{
    char x2;
    int x1;
    short x3;
    long long x4;
}__attribute__((packed));

struct test1
{
    char x2;
    int x1;
    short x3;
    long long x4;
};

struct test2
{
    char x2;
    int x1;
    short x3;
    long long x4;
}__attribute__((aligned(8)));

int main()
{
    printf(&quot;size=%d\n&quot;,sizeof(struct test));
    printf(&quot;size=%d\n&quot;,sizeof(struct test1));
    printf(&quot;size=%d\n&quot;,sizeof(struct test2));
    return 0;
}
</code></pre>
<pre><code>size=15
size=15
size=16
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310231051173.png" alt="" /></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#pragma pack(1)

struct test
{
    char x2;
    int x1;
    short x3;
    long long x4;
}__attribute__((packed));

struct test1
{
    char x2;
    int x1;
    short x3;
    long long x4;
};

struct test2
{
    char x2;
    int x1;
    short x3;
    long long x4;
}__attribute__((aligned(8)));

int main()
{
    printf(&quot;size=%d\n&quot;,sizeof(struct test));
    printf(&quot;size=%d\n&quot;,sizeof(struct test1));
    printf(&quot;size=%d\n&quot;,sizeof(struct test2));
    return 0;
}
</code></pre>
<pre><code>size=15
size=16
size=16
</code></pre>
<h2 id="第4讲-越界访问和缓冲区溢出攻击"><a class="header" href="#第4讲-越界访问和缓冲区溢出攻击">第4讲 越界访问和缓冲区溢出攻击</a></h2>
<h3 id="越界访问和缓冲区溢出攻击27分钟"><a class="header" href="#越界访问和缓冲区溢出攻击27分钟">越界访问和缓冲区溢出攻击（27分钟）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310231103058.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/202310231104760.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311010842877.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311010846780.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311010850981.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311010858130.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/202311010901873.png" alt="" /></p>
<p>test.c文件内容：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void outputs(char *str)
{
    char buffer[16];
    strcpy(buffer,str);
    printf(&quot;%s\n&quot;,buffer);
}

void cracker(void)
{
    printf(&quot;Being cracked\n&quot;);
}
int main(int argc,char *argv[])
{
    outputs(argv[1]);
    return 0;
}
</code></pre>
<p>main.c文件内容：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#define _GNU_SOURCE
#include &lt;unistd.h&gt;
char code[]=
    &quot;0123456789ABCDEFXXXX&quot;
    &quot;\x11\x84\x04\x08&quot;
    &quot;\x00&quot;;

int main()
{
    char *argv[3];
    argv[0]=&quot;./test&quot;;
    argv[1]=code;
    argv[2]=NULL;
    execve(argv[0],argv,NULL);
    return 0;
}
</code></pre>
<p>在WSL2Ubuntu上运行结果如下：</p>
<pre><code>xxxx@DESKTOP-xxxx:~/csapp$ ./test1
Segmentation fault
xxxx@DESKTOP-xxxx:~/csapp$ ./hello
0123456789ABCDEFXXXX
</code></pre>
<p>这里应该有保护机制，阻止了缓冲区溢出的攻击，直接就输出了Segmentation fault，没能输出&quot;Being cracked&quot;。</p>
<p>当然也可能是没能提供cracker()函数的真正地址。</p>
<h2 id="第八周小测验"><a class="header" href="#第八周小测验">第八周小测验</a></h2>
<h3 id="1求a2地址"><a class="header" href="#1求a2地址">1求<code>a[2]</code>地址</a></h3>
<p>假定全局short型数组a的起始地址为0x804908c，则<code>a[2]</code>的地址是（  C ）。</p>
<p>A.0x8049094</p>
<p>B.0x8049092</p>
<p>C.0x8049090</p>
<p>D.0x804908e</p>
<p>解释：short型的字节大小数为2，<code>&amp;a[0]= 0x804908c</code>,所以0x804908c+2+2=0x8049090</p>
<h3 id="2传值汇编指令"><a class="header" href="#2传值汇编指令">2传值汇编指令</a></h3>
<p>假定全局数组a的声明为<code>char *a[8]</code>，a的首地址为0x80498c0，i 在ECX中，现要将<code>a[i]</code>取到EAX相应宽度的寄存器中，则所用的汇编指令是（ B  ）。</p>
<p>A.mov  0x80498c0( , %ecx), %ah</p>
<p>B.mov  0x80498c0( , %ecx, 4), %eax</p>
<p>C.mov  (0x80498c0, %ecx), %ah</p>
<p>D.mov  (0x80498c0, %ecx, 4), %eax</p>
<p>解释：课程使用IA-32系统，指针型变量的大小为4Byte，%eax为目的寄存器</p>
<h3 id="3传值汇编指令"><a class="header" href="#3传值汇编指令">3传值汇编指令</a></h3>
<p>假定全局数组a的声明为<code>double *a[8]</code>，a的首地址为0x80498c0，i 在ECX中，现要将<code>a[i]</code>取到EAX相应宽度的寄存器中，则所用的汇编指令是（D   ）。</p>
<p>A.mov  (0x80498c0, %ecx, 8), %eax</p>
<p>B.mov  (0x80498c0, %ecx, 4), %eax</p>
<p>C.mov  0x80498c0( , %ecx, 8), %eax</p>
<p>D.mov  0x80498c0( , %ecx, 4), %eax </p>
<p>解释：IA-32系统不管是什么类型的指针，大小都为4byte</p>
<h3 id="4传送首地址汇编指令"><a class="header" href="#4传送首地址汇编指令">4传送首地址汇编指令</a></h3>
<p>假定局部数组a的声明为<code>int a[4]={0, -1, 300, 20}</code>，a的首地址为<code>R[ebp]-16</code>，则将a的首地址取到EDX的汇编指令是（ B ）。</p>
<p>A.movl  -16(%ebp ), %edx</p>
<p>B.leal  -16(%ebp), %edx</p>
<p>C.movl  -16(%ebp, 4), %edx</p>
<p>D.leal  -16(%ebp, 4), %edx</p>
<p>解释：因为是取地址，所以用到加载有效地址leal，又因为是取首地址，无需变址和比例因子。</p>
<h3 id="5详解ptri"><a class="header" href="#5详解ptri">5详解<code>ptr+i</code></a></h3>
<p>某C语言程序中有以下两个变量声明：</p>
<pre><code class="language-c">int  a[10];

int  *ptr=&amp;a[0];
</code></pre>
<p>则ptr+i的值为（ B   ）。</p>
<p>A.<code>&amp;a[0]+8´i</code></p>
<p>B.<code>&amp;a[0]+4´i</code></p>
<p>C.<code>&amp;a[0]+2´i</code></p>
<p>D.<code>&amp;a[0]+i</code></p>
<p>解释：IA-32系统中不管是什么类型的指针，大小都为4B</p>
<h3 id="6二维数组元素地址"><a class="header" href="#6二维数组元素地址">6二维数组元素地址</a></h3>
<p>假定静态short型二维数组b的声明如下：</p>
<pre><code class="language-c">static short b[2][4]={ {2, 9, -1, 5}, {3, 8, 2, -6}};
</code></pre>
<p>若b的首地址为0x8049820，则按行优先存储方式下，数组元素“8”的地址是（  D  ）。</p>
<p>A.0x8049824</p>
<p>B.0x8049828</p>
<p>C.0x8049825</p>
<p>D.0x804982a</p>
<p>解释：8前面有5个元素，大小为5*2=10，所以地址为：0x8049820+a=0x804982a</p>
<h3 id="7指针数组元素的值"><a class="header" href="#7指针数组元素的值">7指针数组元素的值</a></h3>
<p>假定静态short型二维数组b和指针数组pb的声明如下：</p>
<pre><code class="language-c">static short b[2][4]={ {2, 9, -1, 5}, {3, 1, -6, 2 }};

static short *pb[2]={b[0], b[1]};
</code></pre>
<p>若b的首地址为0x8049820，则<code>pb[1]</code>的值是（ C   ）。</p>
<p>A.0x8049824</p>
<p>B.0x8049820</p>
<p>C.0x8049828</p>
<p>D.0x8049822</p>
<p>解释：这里问的是<code>pb[1]</code>这个数组元素的值，显然应该是<code>b[1]</code>，而<code>b[1]</code>应该是指二维数组b的第1行（从0开始）的起始地址。b每行有4个元素，每个元素占两个字节（short型），因而每行占8个字节，因而b的第1行首地址为0x8049820+8=0x8049828。</p>
<h3 id="8指针数组元素的地址"><a class="header" href="#8指针数组元素的地址">8指针数组元素的地址</a></h3>
<p>假定静态short型二维数组b和指针数组pb的声明如下：</p>
<pre><code class="language-c">static short b[2][4]={ {2, 9, -1, 5}, {3, 1, -6, 2 }};

static short *pb[2]={b[0], b[1]};
</code></pre>
<p>若b的首地址为0x8049820，则<code>&amp;pb[1]</code>的值是（   D ）。</p>
<p>A.0x8049830</p>
<p>B.0x8049832</p>
<p>C.0x8049838</p>
<p>D.0x8049834</p>
<p>解释：这里问的是<code>pb[1]</code>这个数组元素的地址，通常pb数组直接在b数组后面分配，因为b数组占2x8=16个单元，因此pb数组的首地址为0x8049820+16=0x8049830。而pb数组的每个元素是一个指针，故占4B，所以<code>pb[1]</code>的地址为0x8049830+4=0x8049834。</p>
<h3 id="9结构体元素赋值汇编指令"><a class="header" href="#9结构体元素赋值汇编指令">9结构体元素赋值汇编指令</a></h3>
<p>假定结构体类型cont_info的声明如下：</p>
<pre><code class="language-c">struct cont_info {

char id[8];

char name [16];

unsigned post;

char address[100];

char phone[20];

} ;
</code></pre>
<p>若结构体变量x初始化定义为struct cont_info x={“00000010”, “ZhangS”, 210022, “273 long street, High Building #3015”, “12345678”}，x的首地址在EDX中，则“unsigned xpost=x.post;”对应汇编指令为（ C ）。</p>
<p>A.leal  0x24(%edx), %eax</p>
<p>B.movl  0x24(%edx), %eax</p>
<p>C.movl  0x18(%edx), %eax</p>
<p>D.leal  0x18(%edx), %eax</p>
<p>解释：0x18=24.且为赋值语句，用movl</p>
<h3 id="10对齐方式"><a class="header" href="#10对齐方式">10对齐方式</a></h3>
<p>以下是关于IA-32处理器对齐方式的叙述，其中错误的是（ D  ）。</p>
<p>A.可以用编译指导语句（如#pragma pack）设置对齐方式</p>
<p>B.不同操作系统采用的对齐策略可能不同</p>
<p>C.对于同一个struct型变量，在不同对齐方式下可能会占用不同大小的存储区</p>
<p>D.总是按其数据宽度进行对齐，例如，double型变量的地址总是8的倍数</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="第七周C语言语句的机器级表示.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="第九周x86-64指令系统.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="第七周C语言语句的机器级表示.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="第九周x86-64指令系统.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
